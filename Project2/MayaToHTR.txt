{
proc string GetFPSAsFloat()
		{
		    string $newTime[];
		    string $fpsValue = "-1";
		    string $timeString[];
		    $timeString[0] = `currentUnit -q -t`;
		    
		    switch ($timeString[0])
		    {
		        case "game":
		        $fpsValue = "15";
		        break;
		        
		        case "film":
		        $fpsValue = "24";
		        break;
		        
		        case "pal":
		        $fpsValue = "25";
		        break;
		        
		        case "ntsc":
		        $fpsValue = "30";
		        break;
		        
		        case "show":
		        $fpsValue = "48";
		        break;
		        
		        case "palf":
		        $fpsValue = "50";
		        break;
		        
		        case "ntscf":
		        $fpsValue = "60";
		        break;
		    }
		    
		    if ($fpsValue == "-1")
		    {
		        $fpsValue = "";
		        
		        tokenize($timeString[0], "fps", $newTime);
		        
		        for ($i = 0; $i < size($newTime); $i++)
		            $fpsValue += $newTime[$i];
		    }
		    
			return $fpsValue;
		}
 proc string RemoveRigNameFromBones(string $boneName)
	{
	    string $newBoneName = "";
	    
	    string $buffer[];
	    tokenize $boneName ":" $buffer;
	  
	     if(size($buffer) > 1)
    	      $newBoneName = $buffer[1];
    	else
    	    $newBoneName = $buffer[0];
	  
		return $newBoneName;
	} 
	proc string GetAngleName(string $angName)
	{
	    string $newAngleName = "";
	    
	    switch ($angName)
	    {
	        case "deg":
	            $newAngleName = "Degrees";
	            break;
	            
	        case "degree":
	            $newAngleName = "Degrees";
	            break;
	            
	        case "rad":
	            $newAngleName = "Radians";
	            break;
	            
	        case "radian":
	            $newAngleName = "Radians";
	            break;
	            
	        default:
	            $newAngleName = "Error in function";
	    }
	  
		return $newAngleName;
	} 
global proc float returnTruncated (float $num, int $places)
    {
        return (trunc($num * pow(10, $places)) / pow(10, $places));
    } 
    
global proc float getJointLength(string $jnt1, string $jnt2)
{
    //get jnt1 worldspace position
    float $jnt2Pos[] = `xform -q -ws -t $jnt1`;

    //get jnt2 worldspace position    
    float $jnt1Pos[] = `xform -q -ws -t $jnt2`;

    //calculate the vector between them
    float $xcomp = $jnt2Pos[0] -$jnt1Pos[0];
    float $ycomp = $jnt2Pos[1] -$jnt1Pos[1];
    float $zcomp = $jnt2Pos[2] -$jnt1Pos[2];

    vector $tmp = << $xcomp, $ycomp, $zcomp>>;

    //get the vector length
    float $res = mag($tmp);
    return $res;
}
//set rotation order to ZYX for better animations
xform -p true -roo zyx;
    
//Get bone length axis
string $temp = `xform -q -roo`;
string $x = `substring $temp 2 2`;

// List all joint objects
string $tempArr[] = `ls -type joint` ;
string $nodess[];

int $nodessCounter = 0;
for ($q = 0; $q < size($tempArr); $q++)
{
    if (`match "rev" $tempArr[$q]` != "rev" && `match "Manip" $tempArr[$q]` != "Manip")
    {
        $nodess[$nodessCounter] = $tempArr[$q];
        $nodessCounter++;
    }
}

//Number of joints in the skeleton
int $numNodes = `size($nodess)`;

// Replace existing items on active list with this
select -r $nodess[0] ;   

//Go up the tree until there is no parent
$relatives[0] = "temp";
while ($relatives[0] != "") {
    $relatives = `listRelatives -p`;
    pickWalk -d up ;
}
string $rootNode[] = `ls -sl` ;
string $myroot = $rootNode[0];
////////////////////////////

//Some lines of code taken from:
//https://nccastaff.bournemouth.ac.uk/jmacey/RobTheBloke/www/mel/#1    

// construct the full path to a file
string $rootName[];
tokenize($rootNode[0], ":", $rootName);
$filename = (`internalVar -userTmpDir` + "/../../../Desktop/"+ $rootName[0] +"_HTR.htr");
//$filename = (`internalVar -userTmpDir` + "/../../../Desktop/"+$node+"_KeyframeOutput.txt");

int $maximumTotalKeyframes = 0;
string $temp2Arr[] = `ls` ;
//Print out all nodes (need to use tempArr because of manip animations)
for($i = 0; $i < size($temp2Arr); $i++)
{
    //Get all listConnections and add to array
    $src_a = `listConnections -s true -d false -c true $temp2Arr[$i]`;
    $src_n = `listConnections -s true -d false $temp2Arr[$i]`;
    
    int $x = 0;
    int $maxFrameOnJoint = 0;
    //Go through all the connections on the node
    for($x=0;$x<size($src_n);$x++) {
        
        $j = $x;
        
        // query the node type of the connected node
        $type = `nodeType $src_n[$x]`;
        
        //How many curves are there?
        int $amountOfCurves = `keyframe -query -keyframeCount $temp2Arr[$i]`;
        
        //For each curve, get the keyframe times
        for($q=0;$q<$amountOfCurves;$q++)
        {            
            float $allKeyframeFrames[] = `keyframe -index $q -q $src_a[$j]`;
            
            //Goes through each keyframe time
            for($p=0;$p<size($allKeyframeFrames);$p++)
            {
                //Gets the highest keyframe times and stores it
                if($allKeyframeFrames[$p] > $maxFrameOnJoint);
                {
                    $maxFrameOnJoint = $allKeyframeFrames[$p];
                }
            }
        }
                  
    }
    if ($maximumTotalKeyframes < $maxFrameOnJoint)
        $maximumTotalKeyframes = $maxFrameOnJoint;
}


// open the file for writing
$file = `fopen $filename "w"`;

//Output file data
fprint $file ("[Header]\n");
fprint $file ("#KeyWord<space>Value<CR>\n");
fprint $file ("FileType htr\n");
fprint $file ("DataType HTRS\n");
fprint $file ("FileVersion 1\n"); //I guess this could change later on
fprint $file ("NumSegments "+ $numNodes + "\n");
fprint $file ("NumFrames " + $maximumTotalKeyframes + "\n");
fprint $file ("DataFrameRate "+ GetFPSAsFloat() + "\n");
fprint $file ("EulerRotationOrder "+ `xform -q -roo` + "\n");
fprint $file ("CalibrationUnits "+ `currentUnit -q -l` + "\n");
fprint $file ("RotationUnits "+ `currentUnit -q -a` + "\n");
fprint $file ("GlobalAxisOfGravity " + "Y" + "\n"); //maybe change later, unsure how
fprint $file ("BoneLengthAxis " + capitalizeString($x) + "\n");
fprint $file ("ScaleFactor " + `jointDisplayScale -q -a` + "\n");
fprint $file ("[SegmentNames&Hierarchy]\n");
fprint $file ("#ObjectName<tab>ParentObjectName<CR>\n");

//reverse the array so they are in the proper order and 
//print out all joints with parent
string $reversedArray[];

for($j = 0; $j < `size($nodess)`; $j++)
{
    $reversedArray[( `size($nodess)` - 1 - $j)] = $nodess[$j];
}

for($i = 0; $i < size($reversedArray); $i++)
{
   string $temp[] = `listRelatives -p $reversedArray[$i]`;
   fprint $file(RemoveRigNameFromBones($reversedArray[$i]) + "\t");
   fprint $file (RemoveRigNameFromBones($temp[0]) + "\n");
}
string $parents[];
float $parentBones[];
for($i = 0; $i < size($reversedArray); $i++)
{
    string $temp[] = `listRelatives -p $reversedArray[$i]`;
    $parents[$i] = $temp[0];
 
    string $currentChild = $reversedArray[$i];
   float $boneLength = getJointLength($parents[$i], $currentChild);
   $parentBones[$i] = $boneLength * 10;
    print($parents[$i] + " " + $parentBones[$i] +  "\n");
    
    
}
//if root node print GLOBAL

fprint $file ("[BasePosition]\n");
fprint $file ("#ObjectName<tab>Tx<tab>Ty<tab>Tz<tab>Rx<tab>Ry<tab>Rz<tab>BoneLength<CR>\n");
$TruncatedValue = 6;
//float $xValue, &yValue, $zValue;
for($i = 0; $i < size($reversedArray); $i++)
{
   float $jointPosition[] = `joint -query -r $reversedArray[$i]`;
   $xValue = returnTruncated(($jointPosition[2] * 10), $TruncatedValue);
   $yValue = returnTruncated(($jointPosition[0] * 10), $TruncatedValue);
   $zValue = returnTruncated(($jointPosition[1] * 10), $TruncatedValue);
   fprint $file (RemoveRigNameFromBones($reversedArray[$i]) + "\t");
   
   
   if ($xValue == 0) 
   {
       fprint $file("0.000000" + "\t");
   }
   else
   {
       fprint $file($xValue + "\t");
   }
   if ($yValue == 0) 
   {
       fprint $file("0.000000" + "\t");
   }
   else
   {
       fprint $file($yValue + "\t");
   }
   if ($zValue == 0) 
   {
       fprint $file("0.000000" + "\t");
   }
   else
   {
       fprint $file($zValue + "\t");
   }
   
   float $jointRotation[] = `joint -query -o $reversedArray[$i]`;
   
   float $x[] = `joint -query -ax $reversedArray[$i]`;
   float $y[] = `joint -query -ay $reversedArray[$i]`;
   float $z[] = `joint -query -az $reversedArray[$i]`;
   
   vector $joint = `xform -q -os -ro $reversedArray[$i]`;
   
   $rotationX = (returnTruncated($joint.x, $TruncatedValue));
   $rotationY = (returnTruncated($joint.y, $TruncatedValue));
   $rotationZ =  (returnTruncated($joint.z, $TruncatedValue));
   
    if ($rotationX == 0) 
   {
       fprint $file("0.000000" + "\t");
   }
   else
   {
       fprint $file($rotationX + "\t");
   }
   if ($rotationY == 0) 
   {
       fprint $file("0.000000" + "\t");
   }
   else
   {
       fprint $file($rotationY + "\t");
   }
   if ($rotationZ == 0) 
   {
       fprint $file("0.000000" + "\t");
   }
   else
   {
       fprint $file($rotationZ + "\t");
   }
    
    fprint $file("\n");

  // fprint $file ($reversedArray[$i] + "\t" + returnTruncated(($jointPosition[2] * 10), $TruncatedValue) + "\t" + returnTruncated(($jointPosition[0] * 10), $TruncatedValue) + "\t" + returnTruncated(($jointPosition[1] * 10), $TruncatedValue) + "\n");
   
}


//print out every joints position, rotation, and bone length in local space
//if root print in global space

//For each joint, print out their position, rotation, and bone length for each frame
for($i = 0; $i < size($nodess); $i++)
{
    string $boneName = RemoveRigNameFromBones($reversedArray[$i]);
    
    fprint $file ("[" + $boneName+ "]\n");
    fprint $file ("#Frame<tab>Tx<tab>Ty<tab>Tz<tab>Rx<tab>Ry<tab>Rz<tab>BoneLength<CR>\n");
    
    //float $y = `currentTime -q`;
    //float $t = `getAttr -time $y ($reversedArray[$i] + ".tx")`;
    //print("\nNode: " + $reversedArray[$i] + " at " + $y + " is " + $t);
    
    //For each bone, go through all the maximum number of keyframes
    for ($f = 0; $f <= $maximumTotalKeyframes; $f++)
    {
        string $Tx = "";
        float $TempTx = `getAttr -time $f ($reversedArray[$i] + ".tx")`;
        if ($TempTx == 0)
            $Tx = "0.000000";
        else
        {
            $Tx = returnTruncated($TempTx, 6);
            if (`match "e" $Tx ` == "e") //For any value that is too small for a computer to read
                $Tx = "0.000000";
        }
        
        string $Ty = "";
        float $TempTy = `getAttr -time $f ($reversedArray[$i] + ".ty")`;
        if ($TempTy == 0)
            $Ty = "0.000000";
        else
        {
            $Ty = returnTruncated($TempTy, 6);
            if (`match "e" $Ty ` == "e") //For any value that is too small for a computer to read
                $Ty = "0.000000";
        }
            
        string $Tz = "";
        float $TempTz = `getAttr -time $f ($reversedArray[$i] + ".tz")`;
        if ($TempTz == 0)
            $Tz = "0.000000";
        else
        {
            $Tz = returnTruncated($TempTz, 6);
            if (`match "e" $Tz ` == "e") //For any value that is too small for a computer to read
                $Tz = "0.000000";
        }
            
        string $Rx = "";
        float $TempRx = `getAttr -time $f ($reversedArray[$i] + ".rx")`;
        if ($TempRx == 0)
            $Rx = "0.000000";
        else
        {
            $Rx = returnTruncated($TempRx, 6);
            if (`match "e" $Rx ` == "e") //For any value that is too small for a computer to read
                $Rx = "0.000000";
        }
            
        string $Ry = "";
        float $TempRy = `getAttr -time $f ($reversedArray[$i] + ".ry")`;
        if ($TempRy == 0)
            $Ry = "0.000000";
        else
        {
            $Ry = returnTruncated($TempRy, 6);
            if (`match "e" $Ry ` == "e") //For any value that is too small for a computer to read
                $Ry = "0.000000";
        }
            
        string $Rz = "";
        float $TempRz = `getAttr -time $f ($reversedArray[$i] + ".rz")`;
        if ($TempRz == 0)
            $Rz = "0.000000";
        else
        {
            $Rz = returnTruncated($TempRz, 6);
            if (`match "e" $Rz ` == "e") //For any value that is too small for a computer to read
                $Rz = "0.000000";
        }
            
        //float $BoneLength = `getAttr -time $f ($reversedArray[$i] + ".tx")`;
        
        fprint $file ($f + "\t" + $Tx + "\t" + $Ty + "\t" + $Tz + "\t" + $Rx + "\t" + $Ry + "\t" + $Rz + "\t" + "BoneLength" + "\n");
    }
}
// close the file
fclose $file;
};