{
proc string GetFPSAsFloat()
		{
		    string $newTime[];
		    string $fpsValue = "-1";
		    string $timeString[];
		    $timeString[0] = `currentUnit -q -t`;
		    
		    switch ($timeString[0])
		    {
		        case "game":
		        $fpsValue = "15";
		        break;
		        
		        case "film":
		        $fpsValue = "24";
		        break;
		        
		        case "pal":
		        $fpsValue = "25";
		        break;
		        
		        case "ntsc":
		        $fpsValue = "30";
		        break;
		        
		        case "show":
		        $fpsValue = "48";
		        break;
		        
		        case "palf":
		        $fpsValue = "50";
		        break;
		        
		        case "ntscf":
		        $fpsValue = "60";
		        break;
		    }
		    
		    if ($fpsValue == "-1")
		    {
		        $fpsValue = "";
		        
		        tokenize($timeString[0], "fps", $newTime);
		        
		        for ($i = 0; $i < size($newTime); $i++)
		            $fpsValue += $newTime[$i];
		    }
		    
			return $fpsValue;
		}
 proc string RemoveRigNameFromBones(string $boneName)
	{
	    string $newBoneName = "";
	    
	    string $buffer[];
	    tokenize $boneName ":" $buffer;
	  
	     if(size($buffer) > 1)
    	      $newBoneName = $buffer[1];
    	else
    	    $newBoneName = $buffer[0];
	  
		return $newBoneName;
	}   
proc string GetAngleName(string $angName)
	{
	    string $newAngleName = "";
	    
	    switch ($angName)
	    {
	        case "deg":
	            $newAngleName = "Degrees";
	            break;
	            
	        case "degree":
	            $newAngleName = "Degrees";
	            break;
	            
	        case "rad":
	            $newAngleName = "Radians";
	            break;
	            
	        case "radian":
	            $newAngleName = "Radians";
	            break;
	            
	        default:
	            $newAngleName = "Error in function";
	    }
	  
		return $newAngleName;
	}
//set rotation order to ZYX for better animations
xform -p true -roo zyx;
    
//Get bone length axis
string $temp = `xform -q -roo`;
string $x = `substring $temp 2 2`;

// List all joint objects
string $tempArr[] = `ls -type joint` ;
string $nodess[];

int $nodessCounter = 0;
for ($q = 0; $q < size($tempArr); $q++)
{
    if (`match "rev" $tempArr[$q]` != "rev" && `match "Manip" $tempArr[$q]` != "Manip")
    {
        $nodess[$nodessCounter] = $tempArr[$q];
        $nodessCounter++;
        print ($tempArr[$q] + "\n");
    }
}

//Number of joints in the skeleton
int $numNodes = `size($nodess)`;

// Replace existing items on active list with this
select -r $nodess[0] ;   

//Go up the tree until there is no parent
$relatives[0] = "temp";
while ($relatives[0] != "") {
    $relatives = `listRelatives -p`;
    pickWalk -d up ;
}
string $rootNode[] = `ls -sl` ;
string $myroot = $rootNode[0];
////////////////////////////

//Some lines of code taken from:
//https://nccastaff.bournemouth.ac.uk/jmacey/RobTheBloke/www/mel/#1    

// construct the full path to a file
string $rootName[];
tokenize($rootNode[0], ":", $rootName);
$filename = (`internalVar -userTmpDir` + "/../../../Desktop/"+ $rootName[0] +"_HTR.htr");
//$filename = (`internalVar -userTmpDir` + "/../../../Desktop/"+$node+"_KeyframeOutput.txt");

int $maximumTotalKeyframes = 0;
//Print out all nodes
for($i = 0; $i < size($nodess); $i++)
{
    string $boneName = RemoveRigNameFromBones($nodess[$i]);
    
    //Get all listConnections and add to array
    $src_a = `listConnections -s true -d false -c true $nodess[$i]`;
    $src_n = `listConnections -s true -d false $nodess[$i]`;
    
    int $x = 0;
    int $maxFrameOnJoint = 0;
    //Go through all the connections on the node
    for($x=0;$x<size($src_n);$x++) {
        //Need to get the second one of each due to staggered output values
        $j = $x*2;
    
        // query the node type of the connected node
        $type = `nodeType $src_n[$x]`;
    
        // see if it's a
        //   time to angular curve
        //   time to length curve  or a
        //   time to unitless curve
        if($type=="animCurveTA" ||
          $type=="animCurveTL" ||
          $type=="animCurveTU") 
        {
            //How many curves are there?
            int $amountOfCurves = `keyframe -query -keyframeCount $nodess[$i]`;
            
            //For each curve, get the keyframe times
            for($q=0;$q<$amountOfCurves;$q++)
            {            
                float $allKeyframeFrames[] = `keyframe -index $q -q $src_a[$j+1]`;
                
                //Goes through each keyframe time
                for($p=0;$p<size($allKeyframeFrames);$p++)
                {
                    //Gets the highest keyframe times and stores it
                    if($allKeyframeFrames[$p] > $maxFrameOnJoint);
                    {
                        $maxFrameOnJoint = $allKeyframeFrames[$p];
                    }
                }
            }
        }          
    }
        
    ///
    //string $boneName = RemoveRigNameFromBones($nodess[$i]);
//    print($boneName + " ");
//    string $boneName2[] = `listRelatives -p $nodess[$i]`;
//    print (RemoveRigNameFromBones($boneName2[0]) + "\n");
    
    if ($maximumTotalKeyframes < $maxFrameOnJoint)
        $maximumTotalKeyframes = $maxFrameOnJoint;
}


// open the file for writing
$file = `fopen $filename "w"`;

//Output file data
fprint $file ("#Motion Analysis HTR \n");
fprint $file ("[Header]\n");
fprint $file ("#KeyWord<space>Value<CR>\n");
fprint $file ("FileType htr\n");
fprint $file ("DataType HTRS\n");
fprint $file ("FileVersion 1\n"); //I guess this could change later on
fprint $file ("NumSegments "+ $numNodes + "\n");
fprint $file ("NumFrames " + $maximumTotalKeyframes + "\n");
fprint $file ("DataFrameRate "+ GetFPSAsFloat() + "\n");
fprint $file ("EulerRotationOrder "+ `xform -q -roo` + "\n");
fprint $file ("CalibrationUnits "+ `currentUnit -q -l` + "\n");
fprint $file ("RotationUnits "+ GetAngleName(`currentUnit -q -a`) + "\n");
fprint $file ("GlobalAxisOfGravity " + "Y" + "\n"); //maybe change later, unsure how
fprint $file ("BoneLengthAxis " + capitalizeString($x) + "\n");
fprint $file ("ScaleFactor " + `jointDisplayScale -q -a` + "\n");
fprint $file ("[SegmentNames&Hierarchy]\n");
fprint $file ("#ObjectName<tab>ParentObjectName<CR>\n");

//reverse the array so they are in the proper order and 
//print out all joints with parent
string $reversedArray[];

for($j = 0; $j < `size($nodess)`; $j++)
{
    $reversedArray[( `size($nodess)` - 1 - $j)] = $nodess[$j];
}

for($i = 0; $i < size($reversedArray); $i++)
{
   string $temp[] = `listRelatives -p $reversedArray[$i]`;
   fprint $file(RemoveRigNameFromBones($reversedArray[$i]) + "\t");
   fprint $file (RemoveRigNameFromBones($temp[0]) + "\n");
}
//if root node print GLOBAL

fprint $file ("[BasePosition]\n");
fprint $file ("#ObjectName<tab>Tx<tab>Ty<tab>Tz<tab>Rx<tab>Ry<tab>Rz<tab>BoneLength<CR>\n");


for($i = 0; $i < size($reversedArray); $i++)
{
    //float $attr1 = `getAttr ($reversedArray[$i] + ".positionX")`;
    //$jointConnections[] = `joint -r $nodess[$i]`;
    //print $jointConnections[0];
    //print ($attr1+ "\n");
    //setAttr ($reversedArray[$i] + ".jointOrientX") $attr1;
    //$myJoint = (joint)$reversedArray[$i];
    //fprint $file(joint`$reversedArray[$i]` -p + "\t");
}



//print out every joints position, rotation, and bone length in local space
//if root print in global space

//For each joint, print out their position, rotation, and bone length for each frame
for($i = 0; $i < size($nodess); $i++)
{
    string $boneName = RemoveRigNameFromBones($nodess[$i]);
    
    //Get all listConnections and add to array
    $src_a = `listConnections -s true -d false -c true $nodess[$i]`;
    $src_n = `listConnections -s true -d false $nodess[$i]`;
    
    int $x = 0;
    //Go through all the connections on the node
    for($x=0;$x<size($src_n);$x++) {
        //Need to get the second one of each due to staggered output values
        $j = $x*2;
    
        // query the node type of the connected node
        $type = `nodeType $src_n[$x]`;
    
        // see if it's a
        //   time to angular curve
        //   time to length curve  or a
        //   time to unitless curve
        if($type=="animCurveTA" ||
          $type=="animCurveTL" ||
          $type=="animCurveTU") 
        {
            //How many curves are there?
            int $amountOfCurves = `keyframe -query -keyframeCount $nodess[$i]`;
            
            //For each curve, get the keyframe times
            for($q=0;$q<$amountOfCurves;$q++)
            {            
                float $allKeyframeFrames[] = `keyframe -index $q -q $src_a[$j+1]`;
                
                //Goes through each keyframe time
                for($p=0;$p<size($allKeyframeFrames);$p++)
                {
                    
                }
            }
        }          
    }
    
    fprint $file ("[" + $boneName+ "]\n");
    fprint $file ("#Tx<tab>Ty<tab>Tz<tab>Rx<tab>Ry<tab>Rz<tab>BoneLength<CR>\n");
}
// close the file
fclose $file;
};